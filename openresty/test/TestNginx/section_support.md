# Sections supported

The following sections are supported:

## [http2](https://metacpan.org/pod/Test::Nginx::Socket#http2)

Enforces the test scaffold to use the HTTP/2 wire protocol to send the test request.

Under the hood, the test scaffold uses the `curl` command-line utility to do the wire communication with the NGINX server. The `curl` utility must be recent enough to support both the `--http2` and `--http2-prior-knowledge` command-line options.

**WARNING:** not all the sections and features are supported when this `--- http2` section is specified. For example, this section cannot be used with `--- pipelined_requests` or `--- raw_request`.

See also the [TEST_NGINX_USE_HTTP2](https://metacpan.org/pod/TEST_NGINX_USE_HTTP2) system environment for the "http2" test mode.

## [config](https://metacpan.org/pod/Test::Nginx::Socket#config)

Content of this section will be included in the "server" part of the generated config file. This is the place where you want to put the "location" directive enabling the module you want to test. Example:

`location /echo {`

 `echo_before_body hello;`

 `echo world;`

`}`

Sometimes you simply don't want to bother copying ten times the same configuration for the ten tests you want to run against your module. One way to do this is to write a config section only for the first test in your `.t` file. All subsequent tests will re-use the same config. Please note that this depends on the order of test, so you should run `prove` with variable `TEST_NGINX_NO_SHUFFLE=1` (see below for more on this variable).

Please note that config section goes through environment variable expansion provided the variables to expand start with TEST_NGINX. So, the following is a perfectly legal (provided `TEST_NGINX_HTML_DIR` is set correctly):

`location /main {`

 `echo_subrequest POST /``sub` `-f` `$TEST_NGINX_HTML_DIR``/blah.txt;`

`}`

## [http_config](https://metacpan.org/pod/Test::Nginx::Socket#http_config)

Content of this section will be included in the "http" part of the generated config file. This is the place where you want to put the "upstream" directive you might want to test. Example:

`upstream database {`

 `postgres_server     127.0.0.1:``$TEST_NGINX_POSTGRESQL_PORT`

 `dbname=ngx_test user=ngx_test`

 `password=wrong_pass;`

`}`

As you guessed from the example above, this section goes through environment variable expansion (variables have to start with TEST_NGINX).

## [main_config](https://metacpan.org/pod/Test::Nginx::Socket#main_config)

Content of this section will be included in the "main" part (or toplevel) of the generated config file. This is very rarely used, except if you are testing nginx core itself. Everything in `--- main_config` will be put before the `http {}` block generated automatically by the test scaffold.

This section goes through environment variable expansion (variables have to start with TEST_NGINX).

## [post_main_config](https://metacpan.org/pod/Test::Nginx::Socket#post_main_config)

Similar to `main_config`, but the content will be put *after* the `http {}` block generated by this module.

## [server_name](https://metacpan.org/pod/Test::Nginx::Socket#server_name)

Specify a custom server name (via the "server_name" nginx config directive) for the current test block. Default to "localhost".

## [init](https://metacpan.org/pod/Test::Nginx::Socket#init)

Run a piece of Perl code specified as the content of this `--- init` section before running the tests for the blocks. Note that it is only run once before *all* the repeated requests for this test block.

## [request](https://metacpan.org/pod/Test::Nginx::Socket#request)

This is probably the most important section. It defines the request(s) you are going to send to the nginx server. It offers a pretty powerful grammar which we are going to walk through one example at a time.

In its most basic form, this section looks like that:

`--- request`

`GET`

This will just do a GET request on the root (i.e. /) of the server using HTTP/1.1.

Of course, you might want to test something else than the root of your web server and even use a different version of HTTP. This is possible:

`--- request`

`GET /foo HTTP/1.0`

Please note that specifying HTTP/1.0 will not prevent Test::Nginx from sending the `Host` header. Actually Test::Nginx always sends 2 headers: `Host` (with value localhost) and `Connection` (with value `close` for simple requests and keep-alive for all but the last pipelined_requests).

You can also add a content to your request:

`--- request`

`POST /foo`

`Hello world`

Test::Nginx will automatically calculate the content length and add the corresponding header for you.

This being said, as soon as you want to POST real data, you will be interested in using the more_headers section and using the power of Test::Base filters to urlencode the content you are sending. Which gives us a slightly more realistic example:

`--- more_headers`

`Content-type: application/x-www-form-urlencoded`

`--- request` `eval`

`use` `[URI::Escape](https://metacpan.org/pod/URI::Escape);`

`"POST /rrd/foo`

`value=``".uri_escape("``N:12345")`

Sometimes a test is more than one request. Typically you want to POST some data and make sure the data has been taken into account with a GET. You can do it using arrays:

`--- request` `eval`

`["POST /users`

`name=foo``", "``GET /users/foo"]`

This way, REST-like interfaces are pretty easy to test.

When you develop nifty nginx modules you will eventually want to test things with buffers and "weird" network conditions. This is where you split your request into network packets:

`--- request` `eval`

`[[``"POST /users\nna"``,` `"me=foo"``]]`

Here, Test::Nginx will first send the request line, the headers it automatically added for you and the first two letters of the body ("na" in our example) in ONE network packet. Then, it will send the next packet (here it's "me=foo"). When we talk about packets here, this is not exactly correct as there is no way to guarantee the behavior of the TCP/IP stack. What Test::Nginx can guarantee is that this will result in two calls to `syswrite`.

A good way to make *almost* sure the two calls result in two packets is to introduce a delay (let's say 2 seconds)before sending the second packet:

`--- request` `eval`

`[[``"POST /users\nna"``, {``value` `=>` `"me=foo"``,` `delay_before` `=> 2}]]`

Of course, everything can be combined till your brain starts boiling ;) :

`--- request` `eval`

`use` `[URI::Escape](https://metacpan.org/pod/URI::Escape);`

`my` `$val``=``"value="``.uri_escape(``"N:12346"``);`

`[["POST /rrd/foo`

`".``substr``(``$val``, 0, 6),`

`{``value` `=>` `substr``(``$val``, 6, 5),` `delay_before``=>5},`

`substr``(``$val``, 11)],` `"GET /rrd/foo"``]`

Adding comments before the actual request spec is also supported, for example,

`--- request`

`# this request contains the URI args`

`# "foo" and "bar":`

`GET /api?foo=1``&bar``=2`

## [request_eval](https://metacpan.org/pod/Test::Nginx::Socket#request_eval)

Use of this section is deprecated and tests using it should replace it with a `request` section with an `eval` filter. More explicitly:

`--- request_eval`

`"POST /echo_body`

`hello\x00\x01\x02`

`world\x03\x04\xff"`

should be replaced by:

`--- request` `eval`

`"POST /echo_body`

`hello\x00\x01\x02`

`world\x03\x04\xff"`

## [pipelined_requests](https://metacpan.org/pod/Test::Nginx::Socket#pipelined_requests)

Specify pipelined requests that use a single keep-alive connection to the server.

Here is an example from ngx_lua's test suite:

`=== TEST 7: discard body`

`--- config`

 `location = /foo {`

 `content_by_lua '`

 `ngx.req.discard_body()`

 `ngx.``say``(``"body: "``, ngx.var.request_body)`

 `';`

 `}`

 `location = /bar {`

 `content_by_lua '`

 `ngx.req.read_body()`

 `ngx.``say``(``"body: "``, ngx.var.request_body)`

 `';`

 `}`

`--- pipelined_requests` `eval`

`["POST /foo`

`hello, world",`

`"POST /bar`

`hiya, world"]`

`--- response_body` `eval`

`[``"body: nil\n"``,`

`"body: hiya, world\n"``]`

## [more_headers](https://metacpan.org/pod/Test::Nginx::Socket#more_headers)

Adds the content of this section as headers to the request being sent. Example:

`--- more_headers`

`X-Foo: blah`

This will add `X-Foo: blah` to the request (on top of the automatically generated headers like `Host`, `Connection` and potentially `Content-Length`).

## [curl](https://metacpan.org/pod/Test::Nginx::Socket#curl)

When this section is specified, the test scaffold will try generating a `curl` command line for the (first) test request.

For example,

`--- request`

`GET /foo/bar?baz=3`

`--- more_headers`

`X-Foo: 3`

`User-Agent: openresty`

`--- curl`

will produce the following line (to `stderr`) while running this test block:

`# curl -i -sS -H 'X-Foo: 3' -A openresty 'http://127.0.0.1:1984/foo/bar?baz=3'`

You need to remember to set the `TEST_NGINX_NO_CLEAN` environment to 1 to prevent the nginx and other processes from quitting automatically upon test exits.

## [response_body_filters](https://metacpan.org/pod/Test::Nginx::Socket#response_body_filters)

Transforms the value of the *actual* response body data through a series of filters, before being matched against the expected response body data specified by the `response_body` or `response_body_like` sections.

The filters can be specified either as names (for builtin filters) or as arbitrary Perl subroutine references.

The following builtin filter names are supported:

[](https://metacpan.org/pod/Test::Nginx::Socket#md5_hex)md5_hex

[](https://metacpan.org/pod/Test::Nginx::Socket#sha1_hex)sha1_hex

[](https://metacpan.org/pod/Test::Nginx::Socket#length)length

[](https://metacpan.org/pod/Test::Nginx::Socket#uc)uc

[](https://metacpan.org/pod/Test::Nginx::Socket#lc)lc

[](https://metacpan.org/pod/Test::Nginx::Socket#ucfirst)ucfirst

[](https://metacpan.org/pod/Test::Nginx::Socket#lcfirst)lcfirst

Their meanings are self-explanatory.

Here is an example:

`=== TEST 1:`

`--- config`

 `location = /t {`

 `echo hello;`

 `}`

`--- request`

 `GET /t`

`--- response_body_filters`

`uc`

`--- response_body`

`HELLO`

Here the actual response body data, `hello`, will go through the fitler, `uc`, to become all-upper-case, before getting matched against the expected pattern specified by the `response_body` section, `HELLO`.

The example above can be rewritten by using raw Perl subroutine reference values:

`=== TEST 1:`

`--- config`

 `location = /t {`

 `echo hello;`

 `}`

`--- request`

 `GET /t`

`--- response_body_filters` `eval`

`\``&CORE::uc`

`--- response_body`

`HELLO`

To reference builtin Perl functions like `\&CORE::uc` and `\&CORE::lc`, you need at least perl 5.16.

Multiple builtin filter names can be specified at the same time and they will be applied in order. For example,

`=== TEST 2:`

`--- config`

 `location = /t {`

 `echo hello;`

 `}`

`--- request`

 `GET /hello`

`--- response_body_filters`

`uc` `lc`

`--- response_body`

`hello`

If the response_body_filters value can also be an array reference, mostly useful for specifying multiple Perl subroutine references as the filters:

`=== TEST 3:`

`--- config`

 `location = /t {`

 `echo hello;`

 `}`

`--- request`

 `GET /hello`

`--- response_body_filters` `eval`

`[\``&CORE::uc``, \``&CORE::lc``]`

`--- response_body`

`hello`

If the response_body_filters value can also be an two-dimensional array reference, it means the actual response body data will be `isolatedly` applied by the indexed array's filters:

`=== TEST 4:`

`--- config`

 `location = /t {`

 `echo hello;`

 `}`

`--- request` `eval`

 `[``'GET /t'``,` `'GET /t'``]`

`--- response_body_filters` `eval`

`[[\``&CORE::uc``, \``&CORE::lc``], [\``&CORE::uc``]]`

`--- response_body` `eval`

`[``'hello'``,` `'HELLO'``]`

## [response_body](https://metacpan.org/pod/Test::Nginx::Socket#response_body)

The expected value for the body of the submitted request.

`--- response_body`

`hello`

If the test is made of multiple requests, then the response_body **MUST** be an array and each request **MUST** return the corresponding expected body:

`--- request` `eval`

`[``"GET /hello"``,` `"GET /world"``]`

`--- response_body` `eval`

`[``"hello"``,` `"world"``]`

## [response_body_eval](https://metacpan.org/pod/Test::Nginx::Socket#response_body_eval)

Use of this section is deprecated and tests using it should replace it with a `request` section with an `eval` filter. Therefore:

`--- response_body_eval`

`"hello\x00\x01\x02`

`world\x03\x04\xff"`

should be replaced by:

`--- response_body` `eval`

`"hello\x00\x01\x02`

`world\x03\x04\xff"`

## [response_body_like](https://metacpan.org/pod/Test::Nginx::Socket#response_body_like)

The body returned by the request MUST match the pattern provided by this section. Example:

`--- response_body_like`

`^elapsed 0\.00[0-5] sec\.$`

If the test is made of multiple requests, then response_body_like **MUST** be an array and each request **MUST** match the corresponding pattern.

## [response_body_unlike](https://metacpan.org/pod/Test::Nginx::Socket#response_body_unlike)

Just like `response_body_like` but this test only pass when the specified pattern does *not* match the actual response body data.

## [response_headers](https://metacpan.org/pod/Test::Nginx::Socket#response_headers)

The headers specified in this section are in the response sent by nginx.

`--- response_headers`

`Content-Type: application/x-resty-dbd-stream`

Of course, you can specify many headers in this section:

`--- response_headers`

`X-Resty-DBD-Module:`

`Content-Type: application/x-resty-dbd-stream`

The test will be successful only if all headers are found in the response with the appropriate values.

If the test is made of multiple requests, then response_headers **MUST** be an array and each element of the array is checked against the response to the corresponding request.

## [response_headers_like](https://metacpan.org/pod/Test::Nginx::Socket#response_headers_like)

The value of the headers returned by nginx match the patterns.

`--- response_headers_like`

`X-Resty-DBD-Module: ngx_drizzle \d+\.\d+\.\d+`

`Content-Type: application/x-resty-dbd-stream`

This will check that the response's `Content-Type` is application/x-resty-dbd-stream and that the `X-Resty-DBD-Module` matches `ngx_drizzle \d+\.\d+\.\d+`.

The test will be successful only if all headers are found in the response and if the values match the patterns.

If the test is made of multiple requests, then response_headers_like **MUST** be an array and each element of the array is checked against the response to the corresponding request.

## [raw_response_headers_like](https://metacpan.org/pod/Test::Nginx::Socket#raw_response_headers_like)

Checks the headers part of the response against this pattern. This is particularly useful when you want to write tests of redirect functions that are not bound to the value of the port your nginx server (under test) is listening to:

`--- raw_response_headers_like: Location: [http://localhost](http://localhost/)(?::\d+)?/foo\r\n`

As usual, if the test is made of multiple requests, then raw_response_headers_like **MUST** be an array.

## [raw_response_headers_unlike](https://metacpan.org/pod/Test::Nginx::Socket#raw_response_headers_unlike)

Just like `raw_response_headers_like` but the subtest only passes when the regex does *not* match the raw response headers string.

## [error_code](https://metacpan.org/pod/Test::Nginx::Socket#error_code)

The expected value of the HTTP response code. If not set, this is assumed to be 200. But you can expect other things such as a redirect:

`--- error_code: 302`

If the test is made of multiple requests, then error_code **MUST** be an array with the expected value for the response status of each request in the test.

## [error_code_like](https://metacpan.org/pod/Test::Nginx::Socket#error_code_like)

Just like `error_code`, but accepts a Perl regex as the value, for example:

`--- error_code_like: ^(?:500)?$`

If the test is made of multiple requests, then error_code_like **MUST** be an array with the expected value for the response status of each request in the test.

## [timeout](https://metacpan.org/pod/Test::Nginx::Socket#timeout)

Specify the timeout value (in seconds) for the HTTP client embedded into the test scaffold. This has nothing to do with the server side configuration. When the timeout expires, the test scaffold will immediately close the socket for connecting to the Nginx server being tested.

Note that, just as almost all the timeout settings in the Nginx world, this timeout also specifies the maximum waiting time between two successive I/O events on the same socket handle, rather than the total waiting time for the current socket operation.

When the timeout setting expires, a test failure will be triggered with the message "ERROR: client socket timed out - TEST NAME", unless you have specified `--- abort` at the same time.

Here is an example:

`=== TEST 1: test timeout`

`--- location`

 `location = /t {`

 `echo_sleep 1;`

 `echo ok;`

 `}`

`--- request`

 `GET /t`

`--- response_body`

`ok`

`--- timeout: 1.5`

An optional time unit can be specified, for example,

`--- timeout: 50ms`

Acceptable time units are `s` (seconds) and `ms` (milliseconds). If no time unit is specified, then default to seconds.

Default to 3s.

## [error_log_file](https://metacpan.org/pod/Test::Nginx::Socket#error_log_file)

Specify the global error log file for the current test block only.

Right now, it will not affect the `--- error_log` section and etc accordingly.

## [error_log](https://metacpan.org/pod/Test::Nginx::Socket#error_log)

Checks if the pattern or multiple patterns all appear in lines of the *error.log* file.

For example,

`=== TEST 1: matched` `with` `j`

`--- config`

 `location /re {`

 `content_by_lua '`

 `m = ngx.re.match(``"hello, 1234"``,` `"([0-9]+)"``,` `"j"``)`

 `if` `m then`

 `ngx.``say``(m[0])`

 `else`

 `ngx.``say``(``"not matched!"``)`

 `end`

 `';`

 `}`

`--- request`

 `GET /re`

`--- response_body`

`1234`

`--- error_log: pcre JIT compiling result: 1`

Then the substring "pcre JIT compiling result: 1" must appear literally in a line of *error.log*.

Multiple patterns are also supported, for example:

`--- error_log` `eval`

`[``"abc"``,` `qr/blah/``]`

then the substring "abc" must appear literally in a line of *error.log*, and the regex `qr/blah` must also match a line in *error.log*.

By default, only the part of the error logs corresponding to the current request is checked. You can make it check accumulated error logs by calling the `check_accum_error_log` Perl function before calling `run_tests` in the boilerplate Perl code above the `__DATA__` line.

## [access_log](https://metacpan.org/pod/Test::Nginx::Socket#access_log)

Similar to the [error_log](https://metacpan.org/pod/error_log) section, but for asserting appearance of patterns in the nginx access log file.

Below is an example:

`=== TEST 1: check access` `log`

`--- config`

 `location /t {`

 `content_by_lua_block {`

 `ngx.``say``(``"hello"``)`

 `}`

 `}`

`--- request`

`GET /t`

`--- response_body`

`hello`

`--- access_log`

`GET /t`

## [abort](https://metacpan.org/pod/Test::Nginx::Socket#abort)

Makes the test scaffold not to treat `--- timeout` expiration as a test failure.

## [shutdown](https://metacpan.org/pod/Test::Nginx::Socket#shutdown)

Perform a `shutdown`() operation on the client socket connecting to Nginx as soon as sending out all the request data. This section takes an (optional) integer value for the argument to the `shutdown` function call. For example,

`---` `shutdown``: 1`

will make the connection stop sending data, which is the default.

## [no_error_log](https://metacpan.org/pod/Test::Nginx::Socket#no_error_log)

Very much like the `--- error_log` section, but does the opposite test, i.e., pass only when the specified patterns of lines do not appear in the *error.log* file at all.

Here is an example:

`--- no_error_log`

`[error]`

This test will fail when any of the line in the *error.log* file contains the string `"[error]"`.

Just like the `--- error_log` section, one can also specify multiple patterns:

`--- no_error_log` `eval`

`[``"abc"``,` `qr/blah/``]`

Then if any line in *error.log* contains the string `"abc"` or match the Perl regex `qr/blah/`, then the test will fail.

## [grep_error_log](https://metacpan.org/pod/Test::Nginx::Socket#grep_error_log)

This section specifies the Perl regex pattern for filtering out the Nginx error logs.

You can specify a verbatim substring being matched in the error log messages, as in

`--- grep_error_log` `chop`

`some thing we want to see`

or specify a Perl regex object to match against the error log message lines, as in

`--- grep_error_log` `eval`

`qr/something should be: \d+/`

All the matched substrings in the error log messages will be concatenated by a newline character as a whole to be compared with the value of the `--- grep_error_log_out` section.

## [grep_error_log_out](https://metacpan.org/pod/Test::Nginx::Socket#grep_error_log_out)

This section contains the expected output for the filtering operations specified by the `--- grep_error_log` section.

If the filtered output varies among the repeated requests (specified by the `repeat_each` function, then you can specify a Perl array as the value, as in

`--- grep_error_log_out` `eval`

`[``"output for req 0"``,` `"output for req 1"``]`

## [log_level](https://metacpan.org/pod/Test::Nginx::Socket#log_level1)

Overrides the default error log level for the current test block.

For example:

`--- log_level: debug`

The default error log level can be specified in the Perl code by calling the `log_level()` function, as in

`use` `[Test::Nginx::Socket](https://metacpan.org/pod/Test::Nginx::Socket);`

`repeat_each(2);`

`plan` `tests` `=> repeat_each() * (3 * blocks());`

`log_level(``'warn'``);`

`run_tests();`

`__DATA__`

`...`

## [raw_request](https://metacpan.org/pod/Test::Nginx::Socket#raw_request)

The exact request to send to nginx. This is useful when you want to test some behaviors that are not available with "request" such as an erroneous `Content-Length` header or splitting packets right in the middle of headers:

`--- raw_request` `eval`

`["POST /rrd/taratata HTTP/1.1\r`

`Host: localhost\r`

`Connection:` `close``\r`

`Content-Type: application/",`

`"x-www-form-urlencoded\r`

`Content-Length:15\r\n\r\nvalue=N%3A12345"]`

This can also be useful to tests "invalid" request lines:

`--- raw_request`

`GET /foo HTTP/2.0 THE_FUTURE_IS_NOW`

## [http09](https://metacpan.org/pod/Test::Nginx::Socket#http09)

Specifies that the HTTP 0.9 protocol is used. This affects how `Test::Nginx::Socket` parses the response.

Below is an example from ngx_headers_more module's test suite:

`=== TEST 38: HTTP 0.9 (set)`

`--- config`

 `location /foo {`

 `more_set_input_headers` `'X-Foo: howdy'``;`

 `echo` `"x-foo: $http_x_foo"``;`

 `}`

`--- raw_request` `eval`

`"GET /foo\r\n"`

`--- response_headers`

`! X-Foo`

`--- response_body`

`x-foo:` 

`--- http09`

## [ignore_response](https://metacpan.org/pod/Test::Nginx::Socket#ignore_response)

Do not attempt to parse the response or run the response related subtests.

## [reload_fails](https://metacpan.org/pod/Test::Nginx::Socket#reload_fails)

Allows the NGINX HUP reload fails, which means that the server will still use the previous test block's nginx configuration.

This only makes sense in the HUP reload testing mode.

## [user_files](https://metacpan.org/pod/Test::Nginx::Socket#user_files)

With this section you can create a file that will be copied in the html directory of the nginx server under test. For example:

`--- user_files`

`>>> blah.txt`

`Hello, world`

will create a file named `blah.txt` in the html directory of the nginx server tested. The file will contain the text "Hello, world".

Multiple files are supported, for example,

`--- user_files`

`>>> foo.txt`

`Hello, world!`

`>>> bar.txt`

`Hello, heaven!`

An optional last modified timestamp (in elpased seconds since Epoch) is supported, for example,

`--- user_files`

`>>> blah.txt 199801171935.33`

`Hello, world`

It's also possible to specify a Perl data structure for the user files to be created, for example,

`--- user_files` `eval`

`[`

 `[` `"foo.txt"` `=>` `"Hello, world!"``, 199801171935.33 ],`

 `[` `"bar.txt"` `=>` `"Hello, heaven!"` `],`

`]`

## [skip_eval](https://metacpan.org/pod/Test::Nginx::Socket#skip_eval)

Skip the specified number of subtests (in the current test block) if the result of running a piece of Perl code is true.

The format for this section is

`--- skip_eval`

`<subtest-count>: <perl-code>`

For example, to skip 3 subtests when the current operating system is not Linux:

`--- skip_eval`

`3: $^O ne` `'linux'`

or equivalently,

`--- skip_eval: 3: $^O ne` `'linux'`

## [skip_nginx](https://metacpan.org/pod/Test::Nginx::Socket#skip_nginx)

Skip the specified number of subtests (in the current test block) for the specified version range of nginx.

The format for this section is

`--- skip_nginx`

`<subtest-count>: <op> <version>`

The <subtest-count> value must be a positive integer. The <op> value could be either `>`, `>=`, `<`, or `<=`. the <version> part is a valid nginx version number, like `1.0.2`.

An example is

`=== TEST 1: sample`

`--- config`

 `location /t { echo hello; }`

`--- request`

 `GET /t`

`--- response_body`

`--- skip_nginx`

`2: < 0.8.54`

That is, skipping 2 subtests in this test block for nginx versions older than 0.8.54.

This `skip_nginx` section only allows you to specify one boolean expression as the skip condition. If you want to use two boolean expressions, you should use the `skip_nginx2` section instead.

## [skip_nginx2](https://metacpan.org/pod/Test::Nginx::Socket#skip_nginx2)

This section is similar to `skip_nginx`, but the skip condition consists of two boolean expressions joined by the operator `and` or `or`.

The format for this section is

`--- skip_nginx2`

`<subtest-count>: <op> <version> and|or <op> <version>`

For example:

`=== TEST 1: sample`

`--- config`

 `location /t { echo hello; }`

`--- request`

 `GET /t`

`--- response_body`

`--- skip_nginx2`

`2: < 0.8.53 and >= 0.8.41`

## [skip_openssl](https://metacpan.org/pod/Test::Nginx::Socket#skip_openssl)

Skip the specified number of subtests (in the current test block) for the specified version range of OpenSSL.

The format for this section is

`--- skip_openssl`

`<subtest-count>: <op> <version>`

The <subtest-count> value must be a positive integer. The <op> value could be either `>`, `>=`, `<`, or `<=`. The <version> part is a valid OpenSSL version number, like `1.1.1` or `1.1.0h`.

An example is

`=== TEST 1: sample`

`--- config`

 `location /t { echo hello; }`

`--- request`

 `GET /t`

`--- response_body`

`--- skip_openssl`

`2: < 1.1.1`

That is, skipping 2 subtests in this test block for OpenSSL versions older than 1.1.1.

This `skip_openssl` section only allows you to specify one boolean expression as the skip condition.

## [todo](https://metacpan.org/pod/Test::Nginx::Socket#todo)

Mark tests as todo. Currently they are not used but they should be.

The format for this section is

`--- todo`

`<subtest-count>: <reason>`

The <subtest-count> value must be a positive integer.

<reason> is logged when you run tests with --directives.

## [stap](https://metacpan.org/pod/Test::Nginx::Socket#stap)

This section is used to specify user systemtap script file (.stp file)

Here's an example:

`=== TEST 1: stap sample`

`--- config`

 `location /t { echo hello; }`

`--- stap`

`probe process(``"nginx"``).function(``"ngx_http_finalize_request"``)`

`{`

 `printf``(``"finalize %s?%s\n"``, ngx_http_req_uri(``$r``),`

 `ngx_http_req_args(``$r``))`

`}`

`--- stap_out`

`finalize /test?a=3``&b``=4`

`--- request`

`GET /test?a=3``&b``=4`

`--- response_body`

`hello`

There's some macros that can be used in the "--- stap" section value. These macros will be expanded by the test scaffold automatically.

[](https://metacpan.org/pod/Test::Nginx::Socket#F(function_name))`F(function_name)`

This expands to `probe process("nginx").function("function_name")`. For example, the sample above can be rewritten as

`=== TEST 1: stap sample`

`--- config`

 `location /t { echo hello; }`

`--- stap`

`F(ngx_http_finalize_request)`

`{`

 `printf``(``"finalize %s?%s\n"``, ngx_http_req_uri(``$r``),`

 `ngx_http_req_args(``$r``))`

`}`

`--- stap_out`

`finalize /test?a=3``&b``=4`

`--- request`

`GET /test?a=3``&b``=4`

`--- response_body`

`hello`

[`T()`](https://metacpan.org/pod/Test::Nginx::Socket#T())

This macro will be expanded to `println("Fire ", pp())`.

[](https://metacpan.org/pod/Test::Nginx::Socket#M(static-probe-name))`M(static-probe-name)`

This macro will be expanded to `probe process("nginx").mark("static-probe-name")`.

For example,

`M(http-subrequest-start)`

`{`

 `...`

`}`

will be expanded to

`probe process(``"nginx"``).mark(``"http-subrequest-start"``)`

`{`

 `...`

`}`

## [stap_out](https://metacpan.org/pod/Test::Nginx::Socket#stap_out)

This section specifies the expected literal output of the systemtap script specified by `stap`.

## [stap_out_like](https://metacpan.org/pod/Test::Nginx::Socket#stap_out_like)

Just like `stap_out`, but specify a Perl regex pattern instead.

## [stap_out_unlike](https://metacpan.org/pod/Test::Nginx::Socket#stap_out_unlike)

Just like `stap_like`, but the subtest only passes when the specified pattern does *not* match the output of the systemtap script.

## [wait](https://metacpan.org/pod/Test::Nginx::Socket#wait)

Takes an integer value for the seconds of time to wait right after processing the Nginx response and before performing the error log and/or systemtap output checks.

## [udp_listen](https://metacpan.org/pod/Test::Nginx::Socket#udp_listen)

Instantiates a UDP server listening on the port specified in the background for the test case to access. The server will be started and shut down at each iteration of the test case (if repeat_each is set to 3, then there are 3 iterations).

The UDP server will first read and discard a datagram and then send back a datagram with the content specified by the `udp_reply` section value.

Here is an example:

`=== TEST 1: udp access`

`--- config`

 `location = /t {`

 `content_by_lua '`

 `local` `udp = ngx.``socket``.udp()`

 `udp:setpeername(``"127.0.0.1"``, 19232)`

 `udp:``send``(``"blah"``)`

 `local` `data, err = udp:receive()`

 `ngx.``say``(``"received: "``, data)`

 `';`

 `}`

`--- udp_listen: 19232`

`--- udp_reply: hello world`

`--- request`

`GET /t`

`--- response_body`

`received: hello world`

Datagram UNIX domain socket is also supported if a path name ending with ".sock" is given to this directive. For instance,

`=== TEST 2: datagram unix domain` `socket` `access`

`--- config`

 `location = /t {`

 `content_by_lua '`

 `local` `udp = ngx.``socket``.udp()`

 `udp:setpeername(``"unix:a.sock"``)`

 `udp:``send``(``"blah"``)`

 `local` `data, err = udp:receive()`

 `ngx.``say``(``"received: "``, data)`

 `';`

 `}`

`--- udp_listen: a.sock`

`--- udp_reply: hello world`

`--- request`

`GET /t`

`--- response_body`

`received: hello world`

## [udp_reply](https://metacpan.org/pod/Test::Nginx::Socket#udp_reply)

This section specifies the datagram reply content for the UDP server created by the `udp_listen` section.

You can also specify a delay time before sending out the reply via the `udp_reply_delay` section. By default, there is no delay.

An array value can be specified to make the embedded UDP server to send multiple replies as specified, for example:

`--- udp_reply` `eval`

`[` `"hello"``,` `"world"` `]`

This section also accepts a Perl subroutine value that can be used to generate dynamic response packet or packets based on the actual query, for example:

`--- udp_reply` `eval`

`sub` `{`

 `my` `$req` `=` `shift``;`

 `return` `"hello, $req"``;`

`}`

The custom Perl subroutine can also return an array reference, for example,

`--- udp_reply` `eval`

`sub` `{`

 `my` `$req` `=` `shift``;`

 `return` `[``"hello, $req"``,` `"hiya, $req"``];`

`}`

See the `udp_listen` section for more details.

## [udp_reply_delay](https://metacpan.org/pod/Test::Nginx::Socket#udp_reply_delay)

This section specifies the delay time before sending out the reply specified by the `udp_reply` section.

It is `0` delay by default.

An optional time unit can be specified, for example,

`--- udp_reply_delay: 50ms`

Acceptable time units are `s` (seconds) and `ms` (milliseconds). If no time unit is specified, then default to seconds.

## [udp_query](https://metacpan.org/pod/Test::Nginx::Socket#udp_query)

Tests whether the UDP query sent to the embedded UDP server is equal to what is specified by this directive.

For example,

`=== TEST 1: udp access`

`--- config`

 `location = /t {`

 `content_by_lua '`

 `local` `udp = ngx.``socket``.udp()`

 `udp:setpeername(``"127.0.0.1"``, 19232)`

 `udp:``send``(``"blah"``)`

 `local` `data, err = udp:receive()`

 `ngx.``say``(``"received: "``, data)`

 `';`

 `}`

`--- udp_listen: 19232`

`--- udp_reply: hello world`

`--- request`

`GET /t`

`--- udp_query: hello world`

`--- response_body`

`received: hello world`

## [tcp_listen](https://metacpan.org/pod/Test::Nginx::Socket#tcp_listen)

Just like `udp_listen`, but starts an embedded TCP server listening on the port specified. For example,

`--- tcp_listen: 12345`

Stream-typed unix domain socket is also supported. Just specify the path to the socket file, as in

`--- tcp_listen: /tmp/``my``-``socket``.sock`

## [tcp_no_close](https://metacpan.org/pod/Test::Nginx::Socket#tcp_no_close)

When this section is present, the embedded TCP server (if any) will not close the current TCP connection.

## [tcp_reply_delay](https://metacpan.org/pod/Test::Nginx::Socket#tcp_reply_delay)

Just like `udp_reply_delay`, but for the embedded TCP server.

## [tcp_reply](https://metacpan.org/pod/Test::Nginx::Socket#tcp_reply)

Just like `udp_reply`, but for the embedded TCP server.

Like the `udp_reply` section, this section also accepts a Perl subroutine value that can be used to generate dynamic response packet or packets based on the actual query, for example:

`--- tcp_reply` `eval`

`sub` `{`

 `my` `$req` `=` `shift``;`

 `return` `"hello, $req"``;`

`}`

The custom Perl subroutine can also return an array reference, for example,

`--- tcp_reply` `eval`

`sub` `{`

 `my` `$req` `=` `shift``;`

 `return` `[``"hello, $req"``,` `"hiya, $req"``];`

`}`

## [tcp_query](https://metacpan.org/pod/Test::Nginx::Socket#tcp_query)

Just like `udp_query`, but for the embedded TCP server.

## [tcp_query_len](https://metacpan.org/pod/Test::Nginx::Socket#tcp_query_len)

Specifies the expected TCP query received by the embedded TCP server.

If `tcp_query` is specified, `tcp_query_len` defaults to the length of the value of `tcp_query`.

## [tcp_shutdown](https://metacpan.org/pod/Test::Nginx::Socket#tcp_shutdown)

Shuts down the reading part, writing part, or both in the embedded TCP server as soon as a new connection is established. Its value specifies which part to shut down: 0 for read part only, 1 for write part only, and 2 for both directions.

## [raw_request_middle_delay](https://metacpan.org/pod/Test::Nginx::Socket#raw_request_middle_delay)

Delay in sec between sending successive packets in the "raw_request" array value. Also used when a request is split in packets.

## [no_check_leak](https://metacpan.org/pod/Test::Nginx::Socket#no_check_leak)

Skip the tests in the current test block in the "check leak" testing mode (i.e, with `TEST_NGINX_CHECK_LEAK`=1).

## [must_die](https://metacpan.org/pod/Test::Nginx::Socket#must_die)

Test the cases that Nginx must die right after starting. If a value is specified, the exit code must match the specified value.

Normal request and response cycle is not done. But you can still use the `error_log` section to check if there is an error message to be seen.

This is meant to test bogus configuration is noticed and given proper error message. It is normal to see stderr error message when running these tests.

Below is an example:

`=== TEST 1: bad` `"return"` `directive`

`--- config`

 `location = /t {`

 `return` `a b c;`

 `}`

`--- request`

 `GET /t`

`--- must_die`

`--- error_log`

`invalid number of arguments in` `"return"` `directive`

`--- no_error_log`

`[error]`

This configuration ignores `TEST_NGINX_USE_VALGRIND` `TEST_NGINX_USE_STAP` or `TEST_NGINX_CHECK_LEAK` since there is no point to check other things when the nginx is expected to die right away.

This directive is handled before checking `TEST_NGINX_IGNORE_MISSING_DIRECTIVES`.

## [server_addr_for_client](https://metacpan.org/pod/Test::Nginx::Socket#server_addr_for_client)

This section specifies the server address Test::Nginx will connect to. If server_addr_for_client is not set, then 127.0.0.1 is used.