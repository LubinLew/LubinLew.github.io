# 

重要知识点

‌

1.正数在计算机内存中以原码的形式存储，但是负数以补码的形式存储在内存中，-1在内存中是以所有位为1的形式存储的，即下面这种二进制形式(1111,1111,1111,1111,1111,1111,1111,1111)(1111,1111,1111,1111,1111,1111,1111,1111)2进制补码​ ，**负数的补码是在原码的基础上除符号位外其余位取反后+1**。

‌

2.有符号整型进行移位操作结果是与编译器有关的,简而言之,不要对有符号整型数进行位移操作，否则代码不具有移植性.

‌

3.各种数据类型的字节数 

| 数据类型      | 32位   | 64位   |
| --------- | ----- | ----- |
| char      | 1     | 1     |
| short     | 2     | 2     |
| int       | 4     | 4     |
| **long**  | **4** | **8** |
| long long | 8     | 8     |
| float     | 4     | 4     |
| double    | 8     | 8     |

‌

# 

int 的取值范围

‌

int通常为32位，但是在一些嵌入式中有16的情况，这里假定就是32位的情况。int为有符号类型，所以第1位为正负标记位，其他31位为数据位，所以int的取值范围为 [−2<sup>31</sup> ~ 2<sup>31</sup>−1 ]，

‌

最小值的情况是 32位均为1， 但这是原码，计算补码为 (1000,0000,0000,0000,0000,0000,0000,0000)(1000,0000,0000,0000,0000,0000,0000,0000)2进制补码​, 所以最小值为 1左移31位。

‌

最大值情况是首位为0其他31位为1的情况，这正好与上面最小值补码的情况相反。

```c
#define INT_MIN (1U<<31)
#define INT_MAX (～INT_MIN)
```

经过上面的分析，我们还可以得倒以下的结论

```c
INT_MAX == INT_MIN - 1; //true
INT_MIN == INT_MAX + 1; //true
```

unsigned int 取值范围

‌

这个非常好理解，将0U全部位取反，即可得到最大值，而且无论int是几个字节的，这个方法都是可行的，即该方法是可移植的。

```c
#define UINT_MAX (~0U)
#define UINT_MIN (0)
```

long 和 unsigned long

‌

与上面的 int unsigned int 相同，只是在64位机器上偏移位数不同。
